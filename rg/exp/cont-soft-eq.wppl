var iterate = function(n, init, f) {
  if (n === 0) {
    return [];
  } else {
    var val = f(init);
    return [val].concat(iterate(n - 1, val, f));
  }
};

var step = function(guide, state, reparam) {
  var embed = guide('embed'),
      predict = guide('predict'),
      update = guide('update');

  var i = state.i;
  var p = predict(state);

  var val = sample(Gaussian({mu: 0, sigma: 1}), {
    guide: Gaussian(p),
    reparam: reparam
  });

  var ctx = update(state, embed(val));

  return {i: state.i + 1, ctx: ctx, val: val};
};

var prior = function(task, n, guide, reparam) {
  var initialState = {i: 0, ctx: guide('initialCtx')};
  return iterate(n, initialState, function(state) {
    return step(guide, state, reparam);
  });
};

var model = function(task, n, guide, reparam) {
  var steps = prior(task, n, guide, reparam);
  return task(_.pluck(steps, 'val'));
};

var softEqTask = function(vals) {
  assert.ok(vals.length >= 2);
  var x = first(vals);
  var y = last(vals);
  //var score = Gaussian({mu: x-y, sigma: .1}).score(0);
  var score = -40 * Math.pow(x - y, 2);
  factor(score);
  return [x, y];
};

var embed = function(x) {
  return Vector([x]);
};

var adapt = function(h, args) {
  var hdim = args.hdim;
  var w = param({name: 'adapt-w', dims: [2, hdim]});
  var b = param({name: 'adapt-b', dims: [2, 1]});
  var o = T.add(T.dot(w, h), b);
  //return toscalar(o);
  return {mu: T.get(o, 0), sigma: softplus(T.get(o, 1))};
};

var mfadapt = function(pos) {
  return {mu: T.get(pos, 0), sigma: softplus(T.get(pos, 1))};
};

var opt = function(task, n, guide, reparam, annealFactors, callback) {
  return Optimize(function() {
    return model(task, n, guide, reparam);
  }, {
    steps: 20000,
    //showGradNorm: 1,
    //clip: 1,
    estimator: {ELBO: {samples: 10, annealFactors}},
    optMethod: {adam: {stepSize: .001}},
    onFinish: callback
  });
};

var opt2 = function(task, n, guide, callback) {

  var _model = function(g) {
    return function() {
      return model(task, n, g, true);
    };
  };

  // Use the mean field guide when generating example traces to avoid
  // wasting too much computation.
  var mfg = mfGuide({posdim: 2, embed, adapt: mfadapt});

  var m = Infer({
    method: 'SMC',
    particles: 1000,
    rejuvKernel: 'HMC',
    rejuvSteps: 10,
    saveTraces: true,
    ignoreGuide: true
  }, _model(mfg));

  var traces = m.traces;

  var params = Optimize(_model(guide), {
    steps: 4000,
    estimator: {EUBO: {traces, miniBatchSize: 50}},
    optMethod: {adam: {stepSize: 0.001}}, // i suspect bigger steps would be ok
    onFinish: callback
  });

  // Optimize(_model(guide), {
  //   steps: 1,
  //   estimator: {ELBO: {samples: 1000}},
  //   optMethod: {adam: {stepSize: 0}},
  //   params,
  //   verbose: 0,
  //   onFinish(data) {
  //     var elbo = data.history[0];
  //     display(elbo);
  //   }
  // });

  return params;

};

var test = function() {
  var runs = 3; // per condition

  // TODO: Bumping up the number of hidden units looks like it might
  // help when length=4, but doesn't seem to be the fix for longer
  // sequences.
  var n = 4; // size of guide hidden state


  var norm = process.env.norm;
  assert.ok(norm, 'norm not specified');

  var init = process.env.init;
  assert.ok(init, 'init not specified');


  var guides = {
    rnn: rnnGuide({ctxdim: n, hdim: n, posdim: n, embed, adapt, norm, init}),
    // ['irnn', irnnGuide({ctxdim: n, hdim: n, posdim: n, embed, adapt})],
    gru: gruGuide({ctxdim: n, hdim: n, posdim: n, embed, adapt}),
    lstm: lstmGuide({ctxdim: n * 2, hdim: n, posdim: n, embed, adapt})
  };
  var lengths = [2, 4, 8, 16, 32];

  //var guideName = 'lstm';
  var guideName = process.env.guide;
  assert.ok(guideName && _.has(guides, guideName));
  var guide = [guideName, guides[guideName]];

  // var reparam =
  //     process.env.reparam === 'true' ? true :
  //     process.env.reparam === 'false' ? false :
  //     null;
  // assert.ok(reparam !== null);


  var reparam = true;

  var anneal =
      process.env.anneal === 'true' ? true :
      process.env.anneal === 'false' ? false :
      null;
  assert.ok(anneal !== null);

  map(function(i) {
    map(function(len) {
      //var fn = [guide[0], reparam, len, i].join('-');
      var fn = [guide[0], init, norm, 'anneal', anneal, len, i].join('-');
      display(fn);
      opt(softEqTask, len, guide[1], reparam, anneal, function(data) {
        fs.write('out/' + fn + '.json', JSON.stringify(data.history));
      });
      return;
    }, lengths);
  }, _.range(runs));
};

var test2 = function() {
  var runs = 3; // per condition
  var lengths = [2, 4, 8, 16, 32];

  var n = _top.parseInt(process.env.n);
  var guide = rnnGuide({ctxdim: n, hdim: n, posdim: n, embed, adapt});

  map(function(i) {
    map(function(len) {
      var fn = ['rnn', 'n', n, 'len', len, i].join('-');
      display(fn);
      opt2(softEqTask, len, guide, function(data) {
        fs.write('out/' + fn + '.json', JSON.stringify(data.history));
      });
      return;
    }, lengths);
  }, _.range(runs));
};

//test();
test2();
