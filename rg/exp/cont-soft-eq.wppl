var iterate = function(n, init, f) {
  if (n === 0) {
    return [];
  } else {
    var val = f(init);
    return [val].concat(iterate(n - 1, val, f));
  }
};

var step = function(guide, state, reparam) {
  var embed = guide('embed'),
      predict = guide('predict'),
      update = guide('update');

  var i = state.i;
  var p = predict(state);

  var val = sample(Gaussian({mu: 0, sigma: 1}), {
    guide: Gaussian(p),
    reparam: reparam
  });

  var ctx = update(state, embed(val));

  return {i: state.i + 1, ctx: ctx, val: val};
};

var prior = function(task, n, guide, reparam) {
  var initialState = {i: 0, ctx: guide('initialCtx')};
  return iterate(n, initialState, function(state) {
    return step(guide, state, reparam);
  });
};

var model = function(task, n, guide, reparam) {
  var steps = prior(task, n, guide, reparam);
  return task(_.pluck(steps, 'val'));
};

var softEqTask = function(vals) {
  assert.ok(vals.length >= 2);
  var x = first(vals);
  var y = last(vals);
  //var score = Gaussian({mu: x-y, sigma: .1}).score(0);
  var score = -40 * Math.pow(x - y, 2);
  factor(score);
  return [x, y];
};

var embed = function(x) {
  return Vector([x]);
};

var adapt = function(h, args) {
  var hdim = args.hdim;
  var w = param({name: 'adapt-w', dims: [2, hdim]});
  var b = param({name: 'adapt-b', dims: [2, 1]});
  var o = T.add(T.dot(w, h), b);
  //return toscalar(o);
  return {mu: T.get(o, 0), sigma: softplus(T.get(o, 1))};
};


var opt = function(task, n, guide, reparam, callback) {
  return Optimize(function() {
    return model(task, n, guide, reparam);
  }, {
    steps: 20000,
    //showGradNorm: 1,
    //clip: 1,
    estimator: {ELBO: {samples: 10, annealFactors: false}},
    optMethod: {adam: {stepSize: .001}},
    onFinish: callback
  });
};

var test = function() {
  var runs = 3; // per condition

  // TODO: Bumping up the number of hidden units looks like it might
  // help when length=4, but doesn't seem to be the fix for longer
  // sequences.
  var n = 4; // size of guide hidden state


  var norm = process.env.norm;
  assert.ok(norm, 'norm not specified');

  var init = process.env.init;
  assert.ok(init, 'init not specified');


  var guides = {
    rnn: rnnGuide({ctxdim: n, hdim: n, posdim: n, embed, adapt, norm, init}),
    // ['irnn', irnnGuide({ctxdim: n, hdim: n, posdim: n, embed, adapt})],
    gru: gruGuide({ctxdim: n, hdim: n, posdim: n, embed, adapt}),
    lstm: lstmGuide({ctxdim: n * 2, hdim: n, posdim: n, embed, adapt})
  };
  var lengths = [2, 4, 8, 16, 32];

  var guideName = 'rnn';
  // var guideName = process.env.guide;
  // assert.ok(guideName && _.has(guides, guideName));
  var guide = [guideName, guides[guideName]];

  // var reparam =
  //     process.env.reparam === 'true' ? true :
  //     process.env.reparam === 'false' ? false :
  //     null;
  // assert.ok(reparam !== null);


  var reparam = true;


  map(function(i) {
    map(function(len) {
      //var fn = [guide[0], reparam, len, i].join('-');
      var fn = [guide[0], norm, init, len, i].join('-');
      display(fn);
      opt(softEqTask, len, guide[1], reparam, function(data) {
        fs.write('out/' + fn + '.json', JSON.stringify(data.history));
      });
      return;
    }, lengths);
  }, _.range(runs));
};

test();
