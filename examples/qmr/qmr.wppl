// var graph = JSON.parse(fs.read('examples/qmr-graph.json'));

var graph = {
  diseases: [{p: .5}, {p: .5}],
  symptoms: [
    {leakProb: 0.001, parents: [{i: 0, p: .9}, {i: 1, p: .1}]},
    {leakProb: 0.001, parents: [{i: 0, p: .9}, {i: 1, p: .1}]}
  ]
};

//console.log(JSON.stringify(graph, null, 2));

var noisyOrProb = function(node, diseases) {
  var pFalse = (1 - node.leakProb) * product(map(function(parent) {
    return diseases[parent.i] ? (1 - parent.p) : 1;
  }, node.parents));
  return 1 - pFalse;
};

// TODO: Thought - it's unclear to me how to evaluate this in a way
// that will distinguish between mean field and a richer guide.
// (Comparing "true" latents with samples from optimized guide doesn't
// see like it will work. If there are two explanations in the true
// posterior, mean-field will sometimes find the right one because of
// mode seeking, and the structure posterior will onyly sometimes find
// it because it might sample from either mode.) As an alternative,
// can we compute the probability the guide assigns to the "true"
// latents by exploiting the sequentiality? Predict, check score of
// "true" val, pretend "true" val was samples, predict, etc.? The
// problem then is, one of the problems with optimizing the ELBo is
// over confidence, which complicates this comparison.

var model = function() {
  var diseases = map(function(node) {
    return sample(Bernoulli({p: node.p}));
  }, graph.diseases);

  var symptoms = map2(function(node, val) {
    observe(Bernoulli({p: noisyOrProb(node, diseases)}), val);
    //return sample(Bernoulli({p: noisyOrProb(node, diseases)}));
  }, graph.symptoms, [false, true]);

  return {
    diseases: diseases,
    //symptoms: symptoms
  };
};

var q = Infer({
  method: 'optimize',
  samples: 10000,
  steps: 10000,
  optMethod: {adam: {stepSize: 0.01}}
}, function() {
  var obj = model();
  //condition(!obj.symptoms[0] && obj.symptoms[1]);
  return obj.diseases;
});

var p = Enumerate(function() {
  var obj = model();
  //condition(!obj.symptoms[0] && obj.symptoms[1]);
  return obj.diseases;
});

display('p');
display(p.print());
display('q');
display(q.print());

kl(q,p);
