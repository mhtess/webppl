// These are relative to the webppl executable.
var sDir = '../ppaml-cp4/solutions/problem1/';
var pDir = '../ppaml-cp4/problems/problem1/';

// Helpers.

var observe = function(erp, params, val) {
  factor(erp.score(params, val));
};

var matrixRepeat = function(shape, f) {
  var rows = shape[0];
  var cols = shape[1];
  return repeat(rows, function() {
    return repeat(cols, f);
  });
};

// It's interesting to consider writing these in WebPPL.


var gaussianD = function(mean, std) {
  sample(gaussianDriftERP, [mean, std]);
};

var sampleWishart = function(V, dof) {
  var p = V.length;
  assert.ok(dof > p - 1);
  var chol = util.cholesky(V); // For this model V == I hence chol == I?
  var Z = matrixRepeat([p, dof], function() { gaussian(0, 1); });
  var X = numeric.dot(chol, Z);
  return numeric.dot(X, numeric.transpose(X));
};

var sampleMVGaussian = function(mu, Sigma) {
  var d = mu.length;
  var svd = numeric.svd(Sigma);
  var scaledV = map(function(x) {
    numeric.mul(numeric.sqrt(svd.S), x);
  }, numeric.transpose(svd.V));
  var draws = repeat(d, function() { gaussian(0, 1); });
  var xs = numeric.dot(draws, numeric.transpose(scaledV));
  return numeric.add(xs, mu);
};

var loadData = function() {
  // TODO: Should we expose just readFile/writeFile functions since
  // lots of fs isn't useful.
  // TODO: Should we make paths relative to the current program?
  var allData = numeric.parseCSV(fs.readFileSync(pDir + 'problem-1-data.csv', 'utf8'));
  var X = numeric.getBlock(allData, [1,1], [500, 5]);
  var ys = numeric.transpose(numeric.getBlock(allData, [1,6], [500, 6]))[0];
  return { X: X, ys: ys };
};

var wTrue = [-1.731855, 2.986017, 2.698284, -3.591651, -3.714157];

var sqError = function(w) {
  return numeric.norm2Squared(numeric.sub(w, wTrue));
};

// Metric 1.
var computeMSE = function(samples) {
  return util.mse(samples, wTrue);
};

// Metric 2.
var computeTVD = function(samplesFn) {
  var output = exec('java -jar ' + sDir + 'problem-1-total-variation-java/totalvar.jar ' +
                    sDir + 'problem-1-solution-samples.csv ' + samplesFn);
  return output.split('\n').slice(-2, -1)[0].slice(36);
};

var data = loadData();
var dim = 5; // Including bias term.
var I = numeric.identity(dim);

var model = function() {

  var mu = repeat(dim, function() { gaussian(0, 2); });

  var Prec = sample(wishartERP, [I, dim]);
  //var Prec = sampleWishart(I, dim);

  //var w = multivariateGaussian(mu, numeric.inv(Prec));
  //var w = sampleMVGaussian(mu, numeric.inv(Prec));
  var w = sample(multivariateGaussianERP, [mu, numeric.inv(Prec)]);

  query.add('w', w);

  // The version of the model from the Stan code. (Doesn't depend on
  // Prec.)
  //var w = map(function(m) { gaussianD(m, 1); }, mu);

  // It's unclear from the description how this gamma should be
  // parameterized. The code seems to suggest it's like this:
  var tau = gamma(0.5, 2);

  // TODO: No need to accumulate results, perhaps add a forEach2.
  // Although slicing off the tail will still lead to run time
  // quadratic in the length the the input array(s) I think.

  // Writing this as a single factor of the sum of the score speeds up
  // IncrementalMH, recoering the runtime of MCMC.

  map2(function(xs, y) {
    observe(gaussianERP, [numeric.dot(xs, w), 1 / tau], y);
  }, data.X, data.ys);

  return query;
};

// TODO: Callbacks to compute this periodically during inference. Even
// better (perhaps) would be the ability to continute inference.

var computeMetrics = function() {
  var outputFn = 'posteriorSamples.csv';

  // var samples = MCMC(model, {
  //   burn: 0,
  //   lag: 0,
  //   samples: 80e3,
  //   verbose: true,
  //   justSample: true
  // }).samples;

  var samples = _.pluck(_.pluck(IncrementalMH(model, 10e3, {
    verbose: true,
    justSample: true
  }).samples, 'value'), 'w');

  fs.writeFileSync(outputFn, util.toCSV(samples));
  var mse = computeMSE(samples);
  var tvd = computeTVD(outputFn);

  display('');
  display('Mean squared error:       ' + mse);
  display('Total variation distance: ' + tvd);
};

var computeMarginals = function() {
  // From supplied problem-1-solution-posterior.csv
  //        mean  standard deviation
  // w1    -0.65  0.46
  // w2     3.05  0.75
  // w3     2.45  0.76
  // w4    -3.99  0.78
  // w5    -3.52  0.79
  // noise  10.4  0.33
  var posterior = MCMC(model, {
    samples: 2000,
    verbose: true
  });

  var marginals = mapN(function(i) {
    expectation(Enumerate(function() {
      sample(posterior)[i];
    }));
  }, dim);

  display('');
  display('Marginals:');
  display(marginals);
};

computeMetrics();
//computeMarginals();

'done';
