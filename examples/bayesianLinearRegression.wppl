// These are relative to the webppl executable.
var sDir = '../ppaml-cp4/solutions/problem1/';
var pDir = '../ppaml-cp4/problems/problem1/';

// Helpers.

var observe = function(erp, params, val) {
  factor(erp.score(params, val));
};

var matrixRepeat = function(shape, f) {
  var rows = shape[0];
  var cols = shape[1];
  return repeat(rows, function() {
    return repeat(cols, f);
  });
};

// It's interesting to consider writing these in WebPPL.

var sampleWishart = function(V, dof) {
  var p = V.length;
  assert.ok(dof > p - 1);
  var chol = util.cholesky(V); // For this model V == I hence chol == I?
  var Z = matrixRepeat([p, dof], function() { gaussian(0, 1); });
  var X = numeric.dot(chol, Z);
  return numeric.dot(X, numeric.transpose(X));
};

var sampleMVGaussian = function(mu, Sigma) {
  var d = mu.length;
  var svd = numeric.svd(Sigma);
  var scaledV = map(function(x) {
    numeric.mul(numeric.sqrt(svd.S), x);
  }, numeric.transpose(svd.V));
  var draws = repeat(d, function() { gaussian(0, 1); });
  var xs = numeric.dot(draws, numeric.transpose(scaledV));
  return numeric.add(xs, mu);
};

var loadData = function() {
  // TODO: Should we expose just readFile/writeFile functions since
  // lots of fs isn't useful.
  // TODO: Should we make paths relative to the current program?
  var allData = numeric.parseCSV(fs.readFileSync(pDir + 'problem-1-data.csv', 'utf8'));
  var X = numeric.getBlock(allData, [1,1], [500, 5]);
  var ys = numeric.transpose(numeric.getBlock(allData, [1,6], [500, 6]))[0];
  return { X: X, ys: ys };
};

var wTrue = [-1.731855, 2.986017, 2.698284, -3.591651, -3.714157];

var sqError = function(w) {
  return numeric.norm2Squared(numeric.sub(w, wTrue));
};

// Metric 1.
var computeMSE = function(samples) {
  return util.mse(samples, wTrue);
};

// Metric 2.
var computeTVD = function(samplesFn) {
  var output = exec('java -jar ' + sDir + 'problem-1-total-variation-java/totalvar.jar ' +
                    sDir + 'problem-1-solution-samples.csv ' + samplesFn);
  return output.split('\n').slice(-2, -1)[0].slice(36);
};

var data = loadData();
var dim = 5; // Including bias term.
var I = numeric.identity(dim);

var model = function() {

  var mu = repeat(dim, function() { gaussian(0, 2); });

  //var Prec = sample(wishartERP, [I, dim]);
  var Prec = sampleWishart(I, dim);

  //var w = multivariateGaussian(mu, numeric.inv(Prec));
  //var w = sample(mvGaussianDriftERP, [mu, numeric.inv(Prec)]);
  var w = sampleMVGaussian(mu, numeric.inv(Prec));

  // It's unclear from the description how this gamma should be
  // parameterized. The code seems to suggest it's like this:
  var tau = gamma(0.5, 2);

  // TODO: No need to accumulate results, perhaps add a forEach2.
  // Although slicing off the tail will still lead to run time
  // quadratic in the length the the input array(s) I think.
  map2(function(xs, y) {
    observe(gaussianERP, [numeric.dot(xs, w), 1 / tau], y);
  }, data.X, data.ys);

  return w;
};


var posterior = MCMC(model, { burn: 0, lag: 0, samples: 100, verbose: true, justSample: true });

var outputFn = 'posteriorSamples.csv';
fs.writeFileSync(outputFn, util.toCSV(posterior.samples));
var mse = computeMSE(posterior.samples);
var tvd = computeTVD(outputFn);

display('');
display('Mean squared error:       ' + mse);
display('Total variation distance: ' + tvd);

'done';

// TODO: Callbacks to compute this periodically during inference.
// TODO: Even better would be the ability to continute inference.

// 104K iterations: ~8 minutes.

// Metric 1 - expected squared error:
// 5.306494627398419

// Metric 2:
// 0.83

// Metric 2:
// (with mvGaussianDriftERP)
// 0.65

// Metric 2:
// (with sampleWishart & sampleMVGaussian)
// 0.52
